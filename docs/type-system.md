# Type System

sblite uses SQLite for storage but tracks intended PostgreSQL types, enabling clean migration to Supabase.

## Overview

When you create tables through the Admin API, sblite:
1. Creates the SQLite table with appropriate storage types
2. Records intended PostgreSQL types in the `_columns` metadata table
3. Validates data on INSERT/UPDATE against type rules
4. Exports proper PostgreSQL DDL via `sblite migrate export`

## Supported Types

| Type | SQLite Storage | PostgreSQL | REST API Format |
|------|----------------|------------|-----------------|
| `uuid` | TEXT | uuid | `"550e8400-e29b-41d4-a716-446655440000"` |
| `text` | TEXT | text | `"any string"` |
| `integer` | INTEGER | integer | `42` |
| `numeric` | TEXT | numeric | `"123.45"` |
| `boolean` | INTEGER | boolean | `true` / `false` |
| `timestamptz` | TEXT | timestamptz | `"2024-01-15T10:30:00Z"` |
| `jsonb` | TEXT | jsonb | `{"key": "value"}` |
| `bytea` | BLOB | bytea | `"SGVsbG8="` (base64) |

## Type Details

### uuid

RFC 4122 format UUID.

```
Valid:   "550e8400-e29b-41d4-a716-446655440000"
         "550E8400-E29B-41D4-A716-446655440000"  (case-insensitive)
Invalid: "not-a-uuid"
         "550e8400e29b41d4a716446655440000"     (missing hyphens)
```

### text

Any string value. No validation.

### integer

32-bit signed integer (-2,147,483,648 to 2,147,483,647).

```
Valid:   42, -1000, 0, 2147483647
Invalid: "abc", 9999999999999, 3.14
```

### numeric

Arbitrary precision decimal stored as string to preserve precision.

```
Valid:   "123.45", "-99.00", "0", "123456789.123456789"
Invalid: "12.34.56", "abc", "1,234.56"
```

Why string? Floating-point types lose precision. `"0.1"` stored as float becomes `0.10000000000000001`. Storing as string preserves exact values.

### boolean

Boolean value. Accepts `true`, `false`, `0`, or `1`.

```
Valid:   true, false, 0, 1
Invalid: "yes", "no", 2, "true"
```

### timestamptz

ISO 8601 timestamp with timezone. Always stored in UTC.

```
Valid:   "2024-01-15T10:30:00Z"
         "2024-01-15T10:30:00.123Z"
         "2024-01-15T10:30:00+00:00"
Invalid: "2024-01-15"
         "yesterday"
         "Jan 15, 2024"
```

### jsonb

Valid JSON object or array.

```
Valid:   {"key": "value"}
         [1, 2, 3]
         {"nested": {"data": true}}
Invalid: {invalid json}
         "just a string"  (must be object/array)
```

### bytea

Binary data encoded as base64.

```
Valid:   "SGVsbG8="           (decodes to "Hello")
         "AQID"               (decodes to bytes [1,2,3])
Invalid: "not@valid#base64!"
```

## Creating Typed Tables

Use the Admin API to create tables with type metadata:

```bash
curl -X POST http://localhost:8080/admin/v1/tables \
  -H "Content-Type: application/json" \
  -d '{
    "name": "products",
    "columns": [
      {"name": "id", "type": "uuid", "primary": true, "default": "gen_uuid()"},
      {"name": "name", "type": "text", "nullable": false},
      {"name": "price", "type": "numeric"},
      {"name": "in_stock", "type": "boolean", "default": "true"},
      {"name": "metadata", "type": "jsonb"},
      {"name": "created_at", "type": "timestamptz", "default": "now()"}
    ]
  }'
```

### Column Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `name` | string | required | Column name |
| `type` | string | required | One of the 8 supported types |
| `primary` | boolean | false | Primary key |
| `nullable` | boolean | true | Allow NULL values |
| `default` | string | none | Default value expression |

### Default Value Mapping

| API Default | SQLite Expression |
|-------------|-------------------|
| `"gen_uuid()"` | `(lower(hex(randomblob(16))))` |
| `"now()"` | `(datetime('now'))` |
| `"true"` | `1` |
| `"false"` | `0` |
| Literal value | Literal value |

## Validation on Write

When inserting or updating data via the REST API, values are validated against their declared types:

```bash
# This succeeds
curl -X POST http://localhost:8080/rest/v1/products \
  -H "Content-Type: application/json" \
  -d '{"name": "Widget", "price": "29.99", "in_stock": true}'

# This fails - price is not a valid numeric
curl -X POST http://localhost:8080/rest/v1/products \
  -H "Content-Type: application/json" \
  -d '{"name": "Widget", "price": "not-a-number"}'
# Error: column "price": invalid numeric value
```

Tables created via raw SQL (not the Admin API) have no type metadata and skip validation.

## Migration Export

Export PostgreSQL DDL for migration to Supabase:

```bash
# Output to stdout
./sblite migrate export --db data.db

# Output to file
./sblite migrate export --db data.db -o schema.sql
```

### Example Output

```sql
-- Generated by sblite migrate export

CREATE TABLE "products" (
    "id" uuid PRIMARY KEY,
    "name" text NOT NULL,
    "price" numeric,
    "in_stock" boolean DEFAULT true,
    "metadata" jsonb,
    "created_at" timestamptz DEFAULT now()
);
```

### Export Transformations

| sblite Storage | PostgreSQL Export |
|----------------|-------------------|
| TEXT uuid | Output as-is |
| TEXT numeric | Output as-is (preserves precision) |
| INTEGER boolean | Convert 0/1 to false/true |
| TEXT timestamptz | Output as-is (ISO 8601) |
| TEXT jsonb | Output as-is |
| BLOB bytea | Encode as `'\x...'` hex format |

## Schema Metadata

Type information is stored in the `_columns` table:

```sql
SELECT * FROM _columns WHERE table_name = 'products';
```

| table_name | column_name | pg_type | is_nullable | default_value | is_primary |
|------------|-------------|---------|-------------|---------------|------------|
| products | id | uuid | 0 | gen_uuid() | 1 |
| products | name | text | 0 | NULL | 0 |
| products | price | numeric | 1 | NULL | 0 |
| products | in_stock | boolean | 1 | true | 0 |
| products | metadata | jsonb | 1 | NULL | 0 |
| products | created_at | timestamptz | 1 | now() | 0 |

## Types Not Included

These PostgreSQL types are intentionally omitted:

| Type | Alternative |
|------|-------------|
| `varchar(n)` | Use `text` + application validation |
| `date`, `time` | Use `timestamptz` |
| `float`, `double` | Use `numeric` for precision |
| `array` | Use `jsonb` |
| `enum` | Use `text` + application validation |

This keeps the type system simple while covering 95%+ of real-world use cases.
